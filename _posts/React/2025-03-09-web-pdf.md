---
title: "Nuxt 프로젝트에 React 통합하기"

categories:
  - React
tags:
  - React
  - Nuxt

toc: true
toc_sticky: true
toc_label: "목차"

date: 2025-03-01
last_modified_at: 2025-03-01

header:
  teaser: https://github.com/teawon/Algorithm_js/assets/78795820/a4c95f69-ba6d-4e56-a099-8ee993f0478f
---

## 1. 개요

프레임워크는 개발을 용이하게 해주지만, 때로는 확장이나 새로운 기능 추가에 제약을 불러오기도 합니다.

특히, 특정 프레임워크나 환경에서만 실행 가능한 라이브러리는 제한된 선택지를 제공하며, 이로 인해 적합한 솔루션을 찾기 어렵게 만들 수 있습니다. 이러한 점은 아래의 프로젝트에서 직면한 문제와도 맞물렸습니다.

회사의 레거시 시스템은 Nuxt1을 기반으로 운영되고 있었고, 이 환경에서 PDF 생성 모듈을 새롭게 개발해야 했습니다. 그러나 PDF 생성 로직이 이미 React 기반의 라이브러리로 구현되기로 정해진 상황이었기 때문에, 이 두 가지 기술을 조화롭게 결합하는 것이 도전 과제가 되었습니다.

> Nuxt1은 2018년에 출시되었으며, 현재는 deprecated 되어있다.

결국 핵심 과제는, Nuxt1의 레거시 환경에서 요구되는 기능을 구현할 수 있도록 두 상이한 프레임워크를 성공적으로 통합하는 것이었습니다. 이 과정에서 시스템의 기능성을 확장하면서도 기존 시스템의 안정성을 유지하는 솔루션을 마련하고자 했습니다.

이 글에서는 이와 같은 문제를 해결하기 위해 고려했던 다양한 접근 방안과 그 과정에서 마주한 고민들을 탐색하고자 합니다.

> 이미지 넣기 (레거시 프로젝트에 새로운 프레임워크?)

## 2. 기술적 선택의 배경

PDF 모듈개발을 위해서는 다음과 같은 요구사항이 충족되어야 했습니다.

1. 다양한 차트를 그릴 수 있을 것

2. 확대된 PDF가 깨지지 않을 것 (텍스트가 비트맵 기반의 이미지로 처리되어선 안된다)

3. PDF 변환 작업은 프론트엔드에서 이루어져야 한다. (높은 결합도, 작업 의존성을 개선하기 위함)

즉 Canvas기반의 이미지를 사용하지 않아야 했고, 지속적으로 관리하고 확장할 수 있는 프로젝트를 구성하기 위한 조건이 필요했습니다.

가장 직관적인 방법은 Nuxt 프레임워크 내에서 직접 PDF 변환 모듈을 개발하는 것 이지만 Nuxt의 종속성에 의해 선택할 수 있는 차트 생성 및 PDF 변환 라이브러리에는 한계가 있었고, 이로 인해 높은 러닝 커브가 요구되었습니다. 더욱이, 이러한 방법은 지속적인 관리와 유지보수에도 명확한 제약이 따랐습니다.

따라서, 이러한 요구사항을 충족하면서 적정 시간 내 개발이 가능하도록, React와 호환 가능한 라이브러리를 사용하여 PDF 변환 모듈을 구현하기로 처리하게 되었습니다.

그럼에도 불구하고, 여전히 해결해야 할 과제가 있었습니다. 두 서로 다른 프레임워크 간의 통합을 어떻게 처리할 것인가 하는 문제였고, 이에 대해 두 가지 주요 접근 방안을 고려했습니다.

<div class="notice">
 <p>1. 별도의 도메인을 분리하여 특정 URL에 접근했을 때 React 앱을 제한적으로 띄우는 방법</p>
</div>

<div class="notice">
 <p>2. React 모듈을 배포한 후, 배포된 JavaScript 파일을 Nuxt 내부에서 동적으로 읽어들이는 방법</p>
</div>

첫 번째 방법은 별도의 도메인으로 관리하는 점에서, 개별 앱의 독립성을 보장하고 특정 기능을 분리하여 관리할 수 있다는 장점이 있었습니다.

그러나 이 방법은 별도의 도메인 관리 포인트가 늘어나고, URL에 종속되어 특정 페이지에서 모달을 띄우는 등의 사용처에 한계가 있었습니다. 또한, 분리된 두 도메인 간의 인증 처리(Auth)가 복잡해질 수 있다는 단점도 고려해야 했습니다.

<br>

두 번째 접근 방법은 React 모듈을 배포한 뒤, 그 배포된 JavaScript 파일을 Nuxt 내부에서 동적으로 읽어들이는 방식이었습니다.

이 방법은 별도의 도메인 관리를 피할 수 있고, Nuxt 환경 내에서 React 모듈을 유연하게 활용할 수 있다는 점에서 큰 장점이 있었습니다. 이렇게 하면 모듈이 특정 페이지나 구성 요소에 종속되지 않고 쉽게 통합될 수 있습니다.

또한, 클라이언트 측에서 자바스크립트를 호출하여 필요한 기능을 실행할 수 있으므로, 페이지 전환이나 네비게이션에 제한이 없고, 통합된 UI 흐름을 유지할 수 있다는 이점도 있었습니다.

| **접근 방법**                            | **장점**                                              | **단점**                                                                      |
| ---------------------------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------- |
| **1. 별도의 도메인으로 React 앱 띄우기** | - 개별 앱의 독립성 보장<br>- 특정 기능 분리 관리 가능 | - 도메인 관리 포인트 증가<br>- URL 종속으로 사용처 한계<br>- 복잡한 인증 처리 |
| **2. JS 파일을 Nuxt에서 동적 로드**      | - 도메인 관리 불필요<br>- Nuxt 내 유연한 활용 가능    | - CSS 오염문제                                                                |

> 두 방법의 특징 정리

따라서 위와 같은 이유를 고려해 두 번째 방법을 사용해 문제를 해결하고자 하였습니다.

## 4. 구현 세부 사항

서로 다른 프레임워크간의 이벤트를 처리하기 위해 이벤트 기반 접근 방식을 사용하여 두 프레임워크 간의 원활한 통신을 처리하도록 설계하였습니다.

이를 구현하기 위해 `CustomEvent`를 활용하여 이벤트를 생성하고, 이러한 이벤트를 통해 React와 Nuxt 간의 상호작용을 가능하게 했습니다.

### 4. React

#### 4.1 이벤트 정의 및 구조

```ts
// index.html
<html lang="en">
  <head>
    { ... }
  </head>
  <body>
    <div id="react_pdf_module_id"></div>
    { ... }
  </body>
</html>
```

`index.html`은 기존 React 프로젝트에서 사용하는 구조와 동일합니다. 이때 id가 `react_pdf_module_id`인 div 요소는 React 앱이 마운트될 DOM 요소로 지정됩니다.

이를 통해 `ReactDOM.createRoot`를 통해 해당 요소에 React 컴포넌트를 렌더링할 수 있도록 준비합니다

```ts
// global.d.ts

declare global {
  interface Window {
    myMoudle: {
      mountApp: () => void;
      unMountApp: () => void;
      request: (param: { ... }) => void;
      close: () => void;
      { ... }
    };
  }
}

export {};
```

`global.d.ts` 파일에서는 전역 객체 window에 추가될 모듈의 인터페이스를 선언합니다.

이 인터페이스는 `CustomEvent`를 통해 주고받을 이벤트 메서드들을 정의합니다.

```tsx
// main.tsx

const mountApp = (containerId: string) => {
  const container = document.getElementById(containerId);
  if (!container) return;

  if (root) {
    root.unmount();
  }

  root = ReactDOM.createRoot(container);
  root.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>
  );
};

window.pdfModule = {
  mountApp: () => {
    mountApp("react_pdf_module_id");
  },
  unMountApp: () => {
    if (root) {
      root.unmount();
    }
  },
  request: ( param : { ... }) => {
    const event = new CustomEvent("requestEvent", {
      detail: { action: "request", ...param },
    });
    window.dispatchEvent(event);
  },
  close: () => {
    const event = new CustomEvent("closeEvent", {
      detail: { action: "close" },
    });
    window.dispatchEvent(event);
  },
};
```

`main.tsx`에서는 `global.d.ts`에서 정의된 인터페이스에 대한 실제 구현을 작성합니다.

기존의 React 환경에서는 애플리케이션을 시작과 동시에 마운트하는 방식으로 동작했다면, 현재 구조에서는 Nuxt가 앱을 동적으로 제어하고 요청에 따라 특정 이벤트를 발생시켜야 하므로, 각 동작을 별도의 이벤트로 분리하여 처리합니다.

```tsx
const MainPage = () => {
  { ... }

  useEffect(() => {
    const handleAwsReportEvent = (event: CustomEvent<PdfRequestEvent>) => {
      const { action, ...param } = event.detail;

      switch (action) {
        case "request":
          { ... }
          break;
        case "close":
          { ... }
          break;
        default:
          console.error("Unknown action");
      }
    };

    window.addEventListener(
      "pdfModuleEvent",
      handlePdfModuleEvent
    );

    return () => {
      window.removeEventListener(
        "pdfModuleEvent",
        handlePdfModuleEvent
      );
    };
  }, []);

  return (
     <PdfPreviewPage { ... } />
  );
};

export default MainPage;
```

실제 PDF 변환 로직에서의 시작 및 종료를 핸들링하는 이벤트는 구현 페이지에서 다음과 같이 처리합니다.

위 예제는 React 컴포넌트 MainPage에서 이벤트 리스너를 설정하고 이벤트가 발생하면, handlePdfModuleEvent 함수가 호출되어 이벤트의 detail 속성을 기반으로 적절한 동작을 수행합니다.

#### 4.2 빌드 및 캐싱

앞서 구현한 React 모듈은 독립적인 웹사이트가 아니라 Nuxt에서 동적으로 로드되는 특성을 가지고 있습니다.

따라서, 빌드 후 생성된 파일을 Nuxt가 단순히 읽어들이기만 한다면, 브라우저 캐싱으로 인해 이전 버전의 파일을 계속 읽어오는 문제가 발생할 수 있습니다.

이 문제를 해결하기 위해, 빌드 시 파일 이름에 해시값을 추가하는 전처리 과정을 통해 캐싱 문제를 해결해야합니다.

// 이미지 넣기

-> 결국 웹에서는 특정 스크립트를 항상 읽지만, 스크립트에서 동적으로 최신 배포된 js 읽어오는 방식으로 동작하도록한다,

```ts
//package.json

{
  { ... }
  "scripts": {
    "build": "tsc && vite build && node innerBuildHash.cjs",
  },
}

```

`package.json`에서는 빌드 프로세스를 정의합니다. 컴파일 작업을 수행하고 아래의 스크립트를 수행해 빌드된 파일의 해시를 처리합니다.

```ts
//innerBuildHash.cjs 예시
const fs = require("fs");
const util = require("util");

const directoryPath = __dirname + "/dist/assets";

util
  .promisify(fs.readdir)(directoryPath)
  .then((files) => {
    const getHashByPath = (regex, files) => {
      const fileList = files.filter((file) => regex.test(file));
      return fileList.length > 0 ? fileList[0].match(regex)[1] : null;
    };

    // 해시 추출
    const mainHash = getHashByPath(/^main-(.*).js$/, files);
    const cssHash = getHashByPath(/^main-(.*).css$/, files);

    // 파일 경로와 대체 로직
    const cacheJsPath = `${directoryPath}/cache.js`;

    try {
      let content = fs.readFileSync(cacheJsPath, "utf-8");
      content = content.replace(/main\.js/g, `main-${mainHash}.js`);
      content = content.replace(/main\.css/g, `main-${cssHash}.css`);
      fs.writeFileSync(cacheJsPath, content, "utf-8");
    } catch (err) {
      console.error("Error processing files:", err);
    }
  })
  .catch((err) => {
    console.error("Error reading directory:", err);
  });
```

위 스크립트 파일을 통해 생성된 파일의 해시 값을 추출하고 이를 기반으로 참조를 업데이트합니다.

```ts
// vite.config.ts

export default defineConfig({
  { ... }
   build: {
    rollupOptions: {
      input: {
        main: './src/main.tsx',
        cache: './src/defaultCache.ts',
      },
      output: {
        entryFileNames: `assets/[name]-[hash].js`,
        chunkFileNames: 'assets/[name].js',
      },
    },
  },
});
```

// 실제 배포에 대한 파일결과, 내용물 예시넣기

### 4.2 Nuxt

```js
<template>
  { .. }
      <div
        id="react_pdf_module_id"
        class="modal-pdf-area">
      </div>
</template>
```

Nuxt에서는 React 모듈이 DOM에 렌더링될 때 사용할 id 값을 지정하여 template을 구성합니다. 이 id 값은 React 앱이 마운트될 DOM 요소를 지정하는 데 사용됩니다.

> 해당 DOM요소에 Pdf모듈이 마운트되며 React앱이 동적으로 로드

```js
<script>
{ ... }
   loadReactApp() {
      const existingScript = document.querySelector(
        'script[data-name="react_pdf_module_id"]'
      )
      if (existingScript) {
        // 로드된 스크립트가 있다면 React 앱 마운트
        window.pdfModule.mountApp()
        this.$emit('scriptLoaded')
        return
      }

      // js read
      const script = document.createElement('script')
      const scriptSrc = `${process.env.REACT_PDF_MODULE_URL}?time=${new Date().getTime()}`
      script.type = 'module'
      script.src = scriptSrc
      script.async = true
      script.onload = () => this.$emit('scriptLoaded')
      script.onerror = () =>
        this.messageShow('pdf 모듈을 불러오는 중 오류가 발생했습니다.')
      document.body.appendChild(script)
    },
    requestPdfModule() {
      window.pdfModule.request({ ... })
    },
    closePdfModule() {
      window.pdfModule.close()
    },
  }
</script>

```

이어서, 스크립트를 동적으로 로드하고 이벤트를 발생시키는 로직을 작성합니다. `loadReactApp` 메서드는 로드된 스크립트 여부를 확인하고, 없는 경우 새로운 스크립트를 생성하여 DOM에 추가합니다.

이때 스크립트를 로드할 때 src URL 뒤에 **현재 시간을 쿼리 파라미터로 추가함**으로써 캐싱 문제를 해결합니다. 이렇게 하면 매번 새로고침할 때마다 브라우저가 항상 최신의 스크립트를 불러오게 됩니다.

추가로 PDF 작업의 요청과 종료 요청에 대한 이벤트 핸들러를 작성합니다.

| 실제 돔에서 읽어오는 사진 넣기

## 5. 트러블 슈팅 및 고려사항

항상 코드가 이상적으로 돌아가면 좋겠지만, 현실적으로 구현 과정에서 겪었던 이슈가 있었습니다. 이러한 문제들과 고민했던 해결 방안들을 다루어보려고 합니다.

### 5.1 CSS 오염

### 5.2 테스트의 어려움

위에서 구현한 PDF 모듈은 결국 이벤트 기반으로 작동하기 때문에 실제 변환된 PDF 결과를 디버깅하거나 코드를 테스트하려면 반복적으로 이벤트를 발생시키고 처리해야 하는 번거로움이 있었습니다.

이 문제를 해결하기 위해, `React-Router`를 사용하여 테스트 전용 페이지를 따로 분리했습니다.

이 페이지에서 자유롭게 테스트를 수행할 수 있도록 설정하였으며, 테스트 페이지는 배포 환경에서는 제외되도록 조건부 렌더링을 적용하여 환경을 구성했습니다.

```ts
// App.tsx

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Router>
        <Routes>
          {/* 디버깅용 확인 페이지 */}
          {import.meta.env.MODE === "development" && (
            <Route path="/*" element={<DevPage />} />
          )}
          <Route path="/*" element={<MainPage />} />
        </Routes>
      </Router>
    </QueryClientProvider>
  );
}
export default App;
```

## 6. 결과 및 정리

## 참고자료

[https://socket.io/docs/v4](https://socket.io/docs/v4)
