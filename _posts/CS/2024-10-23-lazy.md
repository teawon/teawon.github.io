---
title: "지연평가와 실용성"
categories:
  - CS
tags:
  - Yield
  - Generator
toc: true
toc_sticky: true
toc_label: "목차"

date: 2024-10-23
last_modified_at: 2023-10-23

header:
  teaser: https://github.com/teawon/teawon.github.io/assets/78795820/6eeff15c-206a-48d3-893e-f6414b3276e0
---

## 1. 개념

지연 평가(lazy evaluation)는 계산이 실제로 필요할 때까지 평가를 미루는 프로그래밍 기법입니다.

이 개념은 성능 최적화와 자원 관리에 주요한 역할을 하며, 특히 대량의 데이터를 처리하거나 복잡한 계산 작업을 다룰 때 유용하게 사용됩니다.

자바의 `Iterator` 와 `Stream` 에서도 이러한 개념이 사용되고 있으며 자주 사용되곤 하는 자바스크립트의 유틸리티 라이브러리 `Lodash`에서도 지연평가를 위한 메서드를 제공하고 있습니다.

이러한 지연 평가 기능은 얼마나 유의미한 효과를 가지고 있을까요? 단점은 없을까요? 이 글에서는 지연평가의 개념과 사례, 그리고 성능 비교를 통해 효과성을 분석해보고자 합니다.

## 2. 사례

자, 지금부터 아래의 요구사항을 만족하는 코드를 구현해야한다고 가정해봅시다.

<div class="notice">
 <p>1부터 10까지의 숫자에 대해 모든 숫자를 두 배로 만든 후, 3의 배수인 숫자 찾기</p>
</div>

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const transformed = numbers.map((num) => {
  console.log(`${num} -> ${num * 2}`);
  return num * 2;
});

const firstNonMultipleOfThree = transformed.find((num) => {
  console.log(`${num}`);
  return num % 3 === 0;
});

console.log(`result: ${firstNonMultipleOfThree}`);
```

<div class="notice--success notice--base">
<h4>실행 결과</h4>
   <p>1 -> 2</p>
   <p>2 -> 4</p>
   <p>3 -> 6</p>
   <p>4 -> 8</p>
   <p>5 -> 10</p>
   <p>6 -> 12</p>
   <p>7 -> 14</p>
   <p>8 -> 16</p>
   <p>9 -> 18</p>
   <p>10 -> 20</p>
   <p>2</p>
   <p>4</p>
   <p>6</p>
   <p>result: 6</p>
</div>

`map`과 `find`메서드를 통해 계산을 수행했으며, 10개의 숫자에 대해 각각의 연산 **10**번과 탐색의 과정에서 **3번** 총 **13번**의 연산을 수행했습니다. 이렇게 모든 요소에 대해 즉각적으로 수행하는 연산을 **엄격한 평가** 라고 합니다.

<br>

그럼 지연평가의 사례를 확인해볼까요?

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

function* mapGenerator(arr, transform) {
  for (const item of arr) {
    console.log(`${item} -> ${transform(item)}`);
    yield transform(item);
  }
}

function* findGenerator(arr, predicate) {
  for (const item of arr) {.

    console.log(`${item}`);
    if (predicate(item)) {
      yield item;
      break;
    }
  }
}

const mappedNumbers = mapGenerator(numbers, (num) => num * 2);
const firstNonMultipleOfThreeLazyGen = findGenerator(
  mappedNumbers,
  (num) => num % 3 === 0
);

console.log(`result: ${firstNonMultipleOfThreeLazyGen.next().value}`);
```

<div class="notice--success notice--base">
<h4>실행 결과</h4>
   <p>1 -> 2</p>
   <p>2</p>
   <p>2 -> 4</p>
   <p>4</p>
   <p>3 -> 6</p>
   <p>result: 6</p>
</div>

지연평가의 경우 숫자 1,2,3에 대한 연산 **3번**과 탐색의 과정에서 **3번** 총 **6번**의 연산을 수행했습니다.

수행 횟수를 기준으로 2배이상의 차이가 발생한 것이죠. 어떠한 원리에 의해 이러한 차이가 발생한걸까요?

우선 코드에 사용된 `*function 및 yield`에 대해 알아봅시다.

## 3. Generator

**제네레이터(Generator)**는 자바스크립트에서 특별한 유형의 함수로, 함수의 실행을 일시 중지하고 필요한 시점에 결과를 반환하는 방법을 제공합니다.

일반 함수와 구별되는 점은 `function*` 키워드를 사용해 정의하며, 호출 시 일반적인 함수처럼 모든 코드가 한 번에 실행되는 것이 아니라, 각 호출마다 실행이 조금씩 진행됩니다.

`yield` 키워드는 제너레이터 내에서 사용되며, 특정 값이나 표현식을 호출자에게 반환하면서 제너레이터의 실행을 일시 중지합니다. 제너레이터는 이후 호출 시 yield 다음 줄에서 실행을 이어갑니다.

이러한 특징을 통해 데이터의 연산 수행 시점을 "호출 시점"으로 분리할 수 있습니다.

```javascript
function* simpleGenerator() {
  console.log("first  yield");
  yield 1;

  console.log("second yield");
  yield 2;

  console.log("third yield");
  yield 3;
}

// 제너레이터 함수 호출
const generator = simpleGenerator();

console.log(generator.next().value); // first  yield , return 1
console.log(generator.next().value); // second yield , return 2
console.log(generator.next().value); // third yield  return 3
console.log(generator.next().value); // undefined
```

위에서 설명한 대로, 제너레이터와 yield를 사용하면 실행이 필요할 때에만 진행되므로, 모든 데이터가 즉시 변환되거나 탐색되지 않습니다.

즉 이를 통해 메모리 사용량을 줄이고 성능을 최적화 활용할 수 있습니다.

이를 바탕으로 위 사례의 지연평가 코드를 분석한다면 다음과 같이 표현할 수 있습니다.

![example](https://github.com/user-attachments/assets/c4482835-8857-4d0d-81db-8fda59f81aad)

> 자바스크립트의 for...of 문은 이터러블한 객체를 자동으로 진행시켜 내부적으로 next()를 호출한다.

## 4. 성능 비교

## 참고자료
