---
title: 4장 네트워크 계층

categories:
  - Network
tags:
toc: true
toc_sticky: true
toc_label: "목차"

date: 2022-12-16
last_modified_at: 2022-12-16
---

(본 글은 "컴퓨터 네트워킹 하향식 접근" 도서 및 네트워크 프로그래밍 수업 내용을 정리한 글 입니다.)

## 4.1 네트워크 계층

### 4.1.1 네트워크 계층의 하는 일

- 송신자는 세그먼트를 전송(세그먼트는 전송계층의 개념)
  - 세그먼트를 데이터그램으로 캡슐화 (데이터 그램은 네트워크계층의 개념)
- 수신자는 세그먼트를 추출해 전송계층으로 올린다(데이터그램에서 헤더를 땜)

### 역할

- **전달**
  - 입력링크로 들어온 패킷을 적절한 출력 링크로 “이동” 시키는 것
- **라우팅**
  - 패킷의 전달 경로를 결정

### 영역

- **데이터 영역**

  - 전달 기능

- **제어 영역**
  - 네트워크 차원의 로직
  - 라우팅 기능
    1. **전통적 라우팅 알고리즘 [라우터별 제어영역]**
       1. 각각의 라우터들 안에 구현
       2. 라우터는 서로 상호정보를 주고받는다
    2. **소프트웨어 정의 기반 네트워킹(SND) [중앙 집중형 제어 영역]**
       1. 외부 서버에 구현
       2. 외부 제어기가 라우터별 제어기능과 상호동작

## 4.2 라우터 구조

- 제어영역과 데이터영역 2가지의 기능을 수행
- 입력, 스위치, 출력 3개로 나눠서 “전달”위주의 개념에 초점을 맞춰 살펴봅시다.

### 4.2.1 입력 포트 기능

- 입력 포트에서는 최종적으로 “이 패킷을 어디로 보낼 지 결정 후 스위치로 넘긴다”

[라인 종단]

- 비트를 받는 부분

[link layer protocol (=미디어)]

- 프로토콜과 캡슐화 같은 전송을 제어하는 부분

**[큐잉, 포워딩]**

- 큐잉
  - 스위칭 구조로 포워딩속도보다 데이터그램이 빨리 도착하는 경우
- 포워딩
  - 목적지 주소를 보고 포워딩테이블을 검색해 출력포트를 찾는다
    - 목적지 기반 전달과 일반 전달
      **목적지기반 전달** : 목적지 주소를 보고 전달
      **일반 전달** : 헤더의 일부 필드를 보고 전달

### 목적지 기반 전달

- **Longest prefix matching :** 주어진 목적지 주소를가지고 포워딩 테이블을 검색할 때 주소 길이가 가장 긴 것을 선택한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18ec1464-c9f0-4801-a28f-ee49dfe90d65/Untitled.png)

- **TCAMs(T:일시 , Connect accesss 메모리.. 내가 막쓴거임)** : 테이블 크기와 무관하게 **1클럭만**으로 원하는 주소 검색

- 이거 왜 쓰는데?
  1. 주소 길이가 길수록 매칭영역은 줄어든다.
  2. 새로운 주소를 매칭시키기 쉽기 때문에 사용!

### 4.2.2 스위치 구조

Q. 스위칭률

- 단위시간당 얼마나 스위칭 하냐에 대한 비율
- 일반적으로 입력라인 n개에 대해 n배 스위치률이 적정

**#### 메모리 기반 스위칭**

- 1세대 라우터에서 사용 (옛날 방식)
- cpu에게 직접 요청하는 방식
- cpu가 직접 패킷을 제어하는데 메모리로 읽고(1) , 해당하는 출력으로 옮기기(2)번의 메모리 접근 필요

**#### 버스**

- Cpu의 간섭없이 io쪽의 메모리를 읽고 공유버스를 통해 직접 전달하는 방법
- DMA기술을 사용한다
- 단 버스가 사용중이라면 기다려야한다. [버스의 대역폭에 제한을 받는다]

**#### 인터커넥션 네트워크 기반 스위칭 (크로스 바)**

- 입력 n개에 대해 버스를 n\*n개 만들어 버스 대역폭의 한계 극복
- 속도는 빠르지만 하드웨어가 급격하게 커진다
- **반얀 네트워크** = n\*n개의 버스를 사용하지 않고 일부 줄여서 만든다.

### 4.2.3 입력포트 큐잉

- 입력포트의 속도보다 스위칭 속도가 낮으면 발생
- **HOL(head of line)블로킹** : 큐 앞의 대기하는 데이터그램때문에 나머지 데이터그램이 대기해야 함

### 4.2.4 출력포트 큐잉

- 반대로 나가는양 보다 들어오는게(스위치를 거쳐 목적지 포트가 정해진 애들) 많으면 쌓이게 된다

(= 스위칭률이 높으면)

- 버퍼링 : 버퍼에 쌓이게 된다
- 스케줄링 정책을 통해 대기중인 패킷을 선택해 전송을 함

- 버퍼링의 적정량
  - 링크용량이 C일때 다음과 같이 버퍼링의 양을 정한다

### 4.2.5 스케쥴링 정책

링크를 통해 전송할 다음 패킷을 어떻게 선택할 것인가?

1. FIFO : 먼저온놈 먼저 나가기
2. 우선순위 : 우선순위별로 별도의 버퍼를 만들어 높은 순위 위주로 보낸다 (또는 헤더의 우선순위 , 포트번호로 우선순위를 판별한다)
3. **라운드로빈** : 클래스 별로 하나씩 패킷 전송 (가중치 1 1 1)
4. **WFQ**(weight fair queuing) : 라운드로빈 + 가중치가 각각 다르다 (1개식 2개씩 3개씩)

## 4.3 네트워크 계층

### 4.3.1 네트워크 계층의 내부

base : 주소를 보고 라우팅테이블을 통해 경로를 선택하고 링크로 다시 전달

- ip프로토콜 : 데이터그램 포멧
- 라우팅 프로토콜 : 포워딩 테이플을 갱신하고 관리
- **ICMP(인터넷 컨트롤 메세지 프로토콜)**프로토콜 : 오류를 알리는 역할
  - IP기반으로 동작
  - ICMP의 메세지를 데이터그램으로 전달한다
  - 오류 유발한 데이터그램의 첫8바이트와 타입, 코드로 구성
    - 보통 전달되는 앞부분에 TimeStamp를 전달해서 만들어서 현재시간-전송시간을 통해 시간경과 계산에 활용하기도 한다.
    - (보낼때 시간 : 몸통에 담겨진 시간 , 수신된 시간의 차 : 현재시간)
  - 0번은 에코인데 에코request를 보내면 무조건 에코 reply를 보내야함

### 4.3.1.1 ICMP의 예시 (Traceroute)

- 코드 11 : TTL만료
- 코드 3 : 목적지 포트를 찾을 수 없음 (= 최종 목적지 도달)

1. 일단 UDP세그먼트를 만들어서 보내게 된다

   1. 여기서 목적지 포트번호는 존재하지 않을 포트번호로 설정합니다. (그 호스트에서 존재할리없는 ㅇㅇ)
   2. 처음에 TTL1로 만들면 첫번째 라우터에서 TTL이 0이되고 ICMP메세지를 다시 보낸쪽으로 ㅇㅇ
   3. 두번째는 TTL2로 → 두번째 라우터에서 TTL0 → ICMP만들어 다시 출발지로
   4. 이를 계속 반복

1. 결국 목적지에 도달하면? → TTL이 아니라 패킷이 상위로 전달되겠죠?

→ 목적지는 ICMP에서 그 호스트에서 있을 수없는 포트번호로 보냈으니 “IPMP 3번을 보낸다”

→ 출발지에서 이제 3번 메세지를 받으면 하던걸 멈춘다.

→ 각 단계별로 패킷을 3개씩 보내서 도달하는데까지 걸리는 시간을 계산한다

### 4.3.2 IP 데이터 그램 포맷

TTS : 라우터 하나 거칠때 마다 1씩 줄고 0이되면 버린다.

IP주소가 여기서는 핵심

### 4.3.3 단편화와 재결합

- 각 링크 계층은 최대 MTU(최대 전송 크기)를 가지고 있으며 링크 계층마다 값이 다르다
- 만약 MTU이상의 데이터그램이 해당 링크를 지나가면 쪼개는 작업이 필요 → 단편화
- 하나의 데이터그램은 여러 개의 데이터그램으로 단편화 하는데 **최종 목적지에서만 재결합**한다

ex) 4000바이트가 있고 MTU가 1500 , 헤더가 20이면 1480+1480+1020

- 플래그가 0이라면 끝, 1이라면 “내 뒤에 더 있다”는 의미
- Offset은 각 조각의 시작지점을 나타내는 값
  - 표현되는 비트수를 줄이기 위해 8바이트을 1로 나타낸다 (1480/8 = 185)

### 4.3.2 IP주소 체계

- IP주소 : 32비트 , 인터페이스와 호스트식별을 위해 사용
- 인터페이스 : 호스트와 링크사이의 경계

  - 라우터는 여러 인터페이스를 가진다 (다른 링크로 전달해주어야 하므로)
  - 일반 컴퓨터는 보통 2개 (무선, 유선)
    - **무선 : 이더넷 스위치**
    - **유선 : Wifi AP**

- 하나의 스위치를 통해 연결되는 애들은 물리적으로 인터페이스가 연결되어있고 네트워크주소가 같다.
  - ip주소는 네트워크주소(서브넷 부분)와 호스트주소로 나뉜다

→ 즉 컴퓨터 하나하나에 IP가 할당되는게 아니라 인터페이스에 할당되고 그 인터페이스와 컴퓨터가 연결된다.

### 4.3.2.1 서브넷

서브넷 : IP주소에서 같은 서브넷 주소를 가지는 장비 인터페이스 (라우터 없이 물리적 접근 가능)

(내가 옛날에 공부할 때 “지역 네트워크 , 동네”라고 표현했던게 이거인듯!

- 223.1.1.0/ “23” : 여기서 23이 네트워크주소가 23임을 의미한다.
- 서브넷 주소의 개수 : 네트워크 주소의 개수를 새거나, 라우터를 지우면 나오는 덩어리의 개수

### 4.3.2.2 CIDR

- 기존에는 클래스 개념을 사용
  - 각 클래스마다 네트워크주소 , 호스트 주소의 고정된 크기를 가짐
    - A클래스 : 1바이트 네트워크 , 3바이트 호스트
    - B클래스 : 2바이트 네트워크 , 2바이트 호스트
  - 낭비되는 공간이 생기는 단점이 발생
- **CIDR** (Class Less Inter Domain Routing)
  - 네트워크 주소의 길이를 임의로 지정
  - a.b.c.d/x 로 나타내며 x가 네트워크 주소의 비트 수

### 4.3.2.3 DHCP

호스트는 어떻게 IP주소를 얻어오는가? (호스트 주소)

1. 수동으로 직접 입력

   1. 이더넷속성 - IPV4 - 다음 IP주소 사용

1. **DHCP**(다이나믹 호스트 configuration 프로토콜) :
   1. 이더넷속성 - IPV4 - 자동으로 ip주소 받기
   2. DHCP(다이나믹 호스트 configuration 프로토콜) : 서버에서 동적으로 주소를 얻어온다

- 즉 호스트는 원핧 때 동적으로 IP주소를 할당받아 사용할 수 있다
- 자신이 사용중인 주소를 다시 빌리거나 바꿀 수 있다
- 동작 과정

  1. DHCP 발견 : 브로드캐스팅을 통해 전체에게 알린다
  2. DHCP 제공 : 사용가능한 ip주소, 시간정보를 클라이언트에게 알린다
  3. DHCP 요청 : 클라이언트는 이걸 사용하겠다는 요청
  4. DHCP ACK : 허가하는 ACK와 관련정보를 다 보내준다

  (해당 정보를 확인하기 위해 Wireshark를 통해 로그를 봄)

- DHCP는 결국 다음 4가지 요소를 반환한다
  - IP주소
  - 서브넷 마스크
  - 게이트웨이 주소 : 외부로 나갈 때 보내야 하는 라우터의 주소
  - DNS 서버 주소
